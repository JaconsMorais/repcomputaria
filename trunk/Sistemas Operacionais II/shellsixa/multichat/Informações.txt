Marcos Vinicius Bascheira RA 208000516


O Programa é dividido em duas partes, cliente e servidor...

SERVIDOR: Inicialmente executa os procedimentos para poder aguardar por uma conexao como nos programas passados em aula ( criacao do socket do servidor, bind, e listen). Depois o programa cria um thread para ficar aguardando por conexoes (accept) e a cada conexao que chega executa a troca de dados com o cliente para verificar seu login (recebe um pacote contento o nome de usuario e senha do cliente, verifica se a combinacao eh valida e retorna uma resposta para o cliente). Se o login é aceito o socket do cliente é copiado para a lista de clientes conectados. Portanto o programa fica com um thread executando em loop aceitando assim conexoes o tempo todo (menos quando esta verificando o login de algum outro cliente, neste caso o cliente que chega fica aguardando este processo do outro cliente terminar e inicia assim o seu login). Paralelamente a este thread, apos a criacao do mesmo o servidor entra em loop onde aguarda por dados dos clientes conectados. Ele faz isto utilizando a funcao poll() como fala a respeito nos slides das aulas....portanto, ele executa poll() na lista de usuarios conectados ate que tenha algo a ser lido em um deles ou tenha ocorrido erro com algum deles (por exemplo, se um cliente terminou inesperadamente). Quando um destes eventos ocorre ele sai varrendo todos os sockets dos clientes conectados para verificar se tem algo a ser lido ou se for erro....se tem algo a ser lido ele le e verifica se a mensagem eh 'exit', indicando que o cliente está saindo, se nao for ele replica a mensagem lida para todos os usuarios conectados. Se for 'exit' ou se ocorreu erro, ele manda uma mensagem para todos os outros conectados informando da saida deste cliente e o remove da lista. Apos varrer todos ele volta para o inicio do loop para executar o poll novamente, só sai deste loop quando nao ha mais clientes conectados.

CLIENTE: O cliente inicialmente executa os procedimentos para criacao de seu socket assim como o servidor e como estava nos programas dados em aula....entao ele conecta com o servidor (connect) e solicita o nome de usuario e senha. Entao envia o nome de usuario e senha para o servidor e aguarda a resposta do mesmo. Se o login nao for aceito o cliente termina, senao esta conectado. Neste caso ele cria uma thread que ira ficar aguardando por mensagens vindas do servidor, utilizando poll() assim como o servidor, mas neste caso apenas para o socket dele mesmo. Quando recebe uma mensagem ele mostra a mensagem na tela. Paralelamente a este thread o cliente prossegue iniciando um loop onde aguarda por entradas de teclado e em seguida cria a mensagem para ser enviada para o servidor, envia a mensagem e verifica se a sua mensagem foi 'exit'. Em caso afirmativo, ou caso tenha ocorrido erro com o socket, termina o programa.

Considerações importantes: Para facilitar e deixar mais profissional, o que me refiro a mensagens (enviadas e recebidas nos Sockets) nao eh uma string (ou array de char). Para ficar melhor eu criei uma estrutura msg_t (em util.h) que contem o nome de quem criou a mensagem, a mensagem propriamente dita, e um campo que indica o tipo da mensagem (Login, Message, ou Logout). Alem disso, sempre que um usuario conecta ou sai o servidor informa a todos os demais sobre o evento (o usuario XXX (des)conectou-se).
O servidor tambem imprime o tempo todo mensagens na tela informando todos os eventos que vao ocorrendo (O usuario XXX conectou-se, XXX envia:, o usuario XXX desconectou-se).

Estou mandando o codigo do cliente (multichatcli.c), do servidor (multichatsrv.c), dos basicos para os dois (util.h e util.c), os arquivos de compilacao (Makefile e Makefile.dep),  atraves do comando 'make' compila tanto o cliente como o servidor. Nele acrescentei no CL_FLAG (ou algo assim) o parametro -lpthread que indica que o compilador deve usar a biblioteca pthread para compilar, ja que o programa possui funcoes de threads.